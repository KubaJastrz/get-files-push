#!/bin/bash
#
# Attributions:
# - how to detect if force-push is needed  https://stackoverflow.com/a/12258773/6244924
# - how to ignore xargs with empty stdout  https://stackoverflow.com/a/8296746/6244924
# - how to list only merge commits  https://stackoverflow.com/a/25986615/6244924
# - how to detect "base branch"  https://stackoverflow.com/a/17843908/6244924
# - how to create local git remote  https://stackoverflow.com/a/34507038/6244924
# - how to detect empty value in shell  https://serverfault.com/a/382740
# - how to trim whitespace for each line  https://unix.stackexchange.com/a/205854
#

# We need xargs to run only if sdout is not empty
function _xargs() {
  if [[ $OSTYPE == 'darwin'* ]]; then
    xargs $@
  else 
    xargs --no-run-if-empty $@
  fi
}

function detect_upstream_unavailable() {
  git rev-parse @{upstream} >/dev/null 2>&1 || echo 'upstream unavailable'
}

# Checks if force-push is needed by comparing upstream and HEAD.
# If true, prints a list of commits present in upstream but missing in local branch.
# Otherwise, prints nothing.
#
# Source: https://stackoverflow.com/a/12258773/6244924
function detect_force_push() {
  local local_commit=$(git rev-parse HEAD)
  local upstream_commit=$(git rev-parse @{upstream})

  git rev-list $upstream_commit ^$local_commit
}

function detect_merge_commit() {
  if [[ "$(git show -s --pretty='%p' $1 2>/dev/null | wc -w)" -eq 2 ]]; then
    echo 'merge commit'
  fi
}


# Use remote version of branch by default. This way we can compare local branch against latest
# pushed changes.
base_revision='@{upstream}'

if [[ ! -z $(detect_upstream_unavailable) ]] || [[ ! -z $(detect_force_push) ]]; then
  # If force push is needed, we can't compare local changes against upstream as it is out of sync.
  # In that case, let's guess what was the base for local branch. Force push is needed mostly 
  # after rebase to the base branch, so we can assume that the both branches are synced with each 
  # other and the diff will yield the minimum number of files changed.
  base_revision=$(git show-branch \
    | grep "\*" \
    | grep -v "$(git branch --show-current)" \
    | head -n1 \
    | sed 's/.*\[\(.*\)\].*/\1/; s/[\^~].*//'
  )

  if [[ ! -z $(detect_upstream_unavailable) ]]; then
    base_revision=$(git merge-base --fork-point $base_revision)
  else
    base_revision=$(git rev-parse $base_revision)
  fi
fi

git log --no-merges --first-parent --format='%H' $base_revision..HEAD \
  | _xargs git show --name-only --format='' \
  | sort \
  | uniq
